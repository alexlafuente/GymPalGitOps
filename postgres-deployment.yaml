apiVersion: v1
# Persistent storage for Postgres data
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
spec:
  accessModes:
    - ReadWriteOnce # Volume can be mounted as read-write by a single node. This would not work for multi-replica DBs, but we have just one replica here. If we wanted multi-replica, we would need to use StatefulSet instead of Deployment.
  resources:
    requests:
      storage: 500Mi # Requested storage size
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
spec:
  replicas: 1 # Just one replica, as it is a DB. If we wanted scaling, we would need to use StatefulSet insead of Deployment to maintain consistency betewen DBs
  selector:
    matchLabels: # Determine which label (key-value) defines the pods that are part of the pool from this Deployment
      app: postgres
  template:
    metadata:
      labels: # Pod's label
        app: postgres
    spec:
      containers:
        - name: postgres
          image: postgres:15-alpine # Official Postgres image, lightweight Alpine version
          # Environment variables for the container whithin a Pod
          env:
            - name: POSTGRES_DB
              valueFrom:
                configMapKeyRef:
                  name: gympal-config
                  key: POSTGRES_DB
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: gympal-secrets
                  key: POSTGRES_USER
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: gympal-secrets
                  key: POSTGRES_PASSWORD
          ports:
            - containerPort: 5432
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
          readinessProbe: # Check if Postgres is ready to accept connections
            exec: # Use exec to run a command inside the container
              command: ["pg_isready", "-U", "postgres"] # Check if Postgres is ready using pg_isready command
            initialDelaySeconds: 10 # Wait 10 seconds before the first probe
            periodSeconds: 10 # Probe every 10 seconds
            timeoutSeconds: 5 # Timeout after 5 seconds
          livenessProbe: # Check if Postgres is alive
            exec: # Use exec to run a command inside the container
              command: ["pg_isready", "-U", "postgres"] # Check if Postgres is alive using pg_isready command
            initialDelaySeconds: 30 # Wait 30 seconds before the first probe
            periodSeconds: 30 # Probe every 30 seconds
      # Define volumes for the Pod
      volumes:
        - name: postgres-data
          persistentVolumeClaim: # Use the PVC defined above. This ensures data persists across Pod restarts.
            claimName: postgres-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: postgres
spec:
  selector:
    app: postgres
  ports:
    - port: 5432
      targetPort: 5432
  type: ClusterIP # Internal service only accessible within the cluster
